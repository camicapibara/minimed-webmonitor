<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimed Monitor Web</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        .main-container {
            width: 320px;
            height: 240px;
            margin: 0 auto;
            position: relative;
            padding: 0;
            overflow: hidden;
        }
        .status-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 8px;
            background-color: transparent;
        }
        .status-icons {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .status-icon {
            width: 28px;
            height: 28px;
            object-fit: contain;
        }
        .sensor-age-text {
            color: #fff;
            margin-left: -25px;
            font-size: 0.9rem;
        }
        .time {
            font-size: 1.5rem;
            color: #fff;
            font-weight: 400;
        }
        .shield-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
        }
        .shield-background {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 160px;
            height: 160px;
        }
        .shield-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .glucose-content {
            position: relative;
            z-index: 2;
            text-align: center;
        }
        .glucose-value {
            font-size: 3rem;
            font-weight: 400;
            margin: 0;
            line-height: 1;
            color: #fff;
            margin-top: -5px;
        }
        .glucose-unit {
            color: #89abeb;
            font-size: 0.8rem;
            margin-top: 2px;
            font-weight: 300;
        }
        .insulin-container {
            position: absolute;
            bottom: 35px;
            right: 15px;
            text-align: right;
        }
        .insulin-value {
            font-size: 1.5rem;
            font-weight: 400;
            margin: 0;
            line-height: 1;
        }
        .insulin-label {
            color: #fff;
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 1px;
        }
        .last-update {
            position: absolute;
            bottom: 35px;
            left: 20%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 1rem;
            font-weight: 300;
        }
        .calibration-indicator {
            position: relative;
            width: 28px;
            height: 28px;
            margin-right: 6px;
        }
        .calibration-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 4px solid transparent;
            box-sizing: border-box;
            transform-origin: center;
        }
        .calibration-circle.right {
            clip: rect(0, 28px, 28px, 14px);
            transform-origin: center;
        }
        .calibration-circle.left {
            clip: rect(0, 14px, 28px, 0);
            transform-origin: center;
        }
        .calibration-progress {
            display: none;
        }
        .calibration-drop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .drop-white { background-image: url('/static/res/mm_drop_white.png'); }
        .drop-red { background-image: url('/static/res/mm_drop_red.png'); }
        .drop-unk { background-image: url('/static/res/mm_drop_unk.png'); }

        .slider-container {
            width: 100vw;
            height: 240px;
            position: relative;
            overflow: hidden;
            touch-action: pan-x;
        }
        .slider-wrapper {
            display: flex;
            width: 200vw;
            height: 100%;
            position: relative;
            transition: transform 0.3s ease-out;
        }
        .slide {
            width: 100vw;
            height: 100%;
            flex-shrink: 0;
        }
        .graph-container {
            width: 320px;
            height: 240px;
            margin: 0 auto;
            position: relative;
            background-color: #000;
            display: flex;
            flex-direction: column;
        }
        .graph-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .slide-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 10;
        }
        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            transition: background-color 0.3s ease;
        }
        .dot.active { background-color: #fff; }

        #graph { width: 100%; height: 100%; }

        .graph-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #fff;
            width: 100%;
            padding: 5px 0;
        }
        .graph-info span {
            font-size: 0.9rem;
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <div class="slider-container">
        <div class="slider-wrapper">
            <div class="slide">
                <div class="main-container">
                    <div class="status-bar">
                        <div class="status-icons">
                            <img id="batteryIcon" src="" alt="Battery" class="status-icon">
                            <img id="reservoirIcon" src="" alt="Reservoir" class="status-icon">
                            <img id="sensorConnIcon" src="" alt="Sensor Connection" class="status-icon">
                            <div class="calibration-indicator">
                                <div id="calibrationCircle" class="calibration-circle"></div>
                                <div id="calibrationDrop" class="calibration-drop"></div>
                            </div>
                            <img id="sensorAgeIcon" src="" alt="Sensor Age" class="status-icon">
                            <span id="sensorAgeText" class="sensor-age-text"></span>
                        </div>
                        <div class="time" id="lastUpdate">13:25</div>
                    </div>

                    <div class="shield-container">
                        <div class="shield-background">
                            <img src="/static/res/mm_shield_none.png" alt="Shield Background" class="shield-image" id="shieldImage">
                        </div>
                        <div class="glucose-content">
                            <div class="glucose-value" id="glucoseValue">--</div>
                            <div class="glucose-unit">mg/dL</div>
                        </div>
                    </div>

                    <!-- Banner de estado (se muestra/oculta vía JS) -->
                    <img id="pumpBanner" style="position:absolute; left:40px; top:145px; width:240px; height:auto; display:none;" alt="Pump banner">

                    <div class="insulin-container">
                        <div class="insulin-value" id="activeInsulin">1.5 U</div>
                        <div class="insulin-label">Insulina Activa</div>
                    </div>

                    <div class="last-update" id="lastUpdateText">--</div>
                </div>
            </div>
            <div class="slide">
                <div class="graph-container">
                    <div class="status-bar">
                        <div class="graph-info">
                            <span id="graphAvg">Promedio: -- mg/dL</span>
                        </div>
                    </div>
                    <div class="graph-content">
                        <canvas id="graph"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="slide-indicator">
            <div class="dot active"></div>
            <div class="dot"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns/dist/date-fns.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script>
        // Registrar el plugin de anotaciones (modo CDN)
        if (window['chartjs-plugin-annotation']) {
            Chart.register(window['chartjs-plugin-annotation']);
        }

        let allGlucoseData = [];
        let patientMarkers = [];
        let viewStartIndex = 0;
        const POINTS_TO_SHOW = 36; // 3 horas con lecturas cada 5 minutos
        let glucoseChart;

        // Inicializar el gráfico
        function initializeChart() {
            const ctx = document.getElementById('graph').getContext('2d');

            glucoseChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Glucosa',
                        data: [],
                        borderColor: '#ffffff',
                        tension: 0.4,
                        pointRadius: 0,
                        borderWidth: 2,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        y: {
                            min: 40,
                            max: 250,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: {
                                color: '#fff',
                                font: { size: 12 },
                                callback: function(value) {
                                    return [50, 100, 150, 200, 250].includes(value) ? value : '';
                                },
                                stepSize: 50,
                                includeBounds: false
                            }
                        },
                        x: {
                            grid: {
                                color: function(context) {
                                    const label = context.tick?.label;
                                    if (!label) return 'rgba(255, 255, 255, 0.05)';
                                    const [hour, minute] = (label || '').split(':').map(Number);
                                    return (minute >= 58 || minute <= 2) ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.05)';
                                },
                                drawOnChartArea: true
                            },
                            ticks: {
                                color: '#fff',
                                maxRotation: 0,
                                autoSkip: false,
                                font: { size: 12 },
                                callback: function(value) {
                                    const label = this.getLabelForValue(value);
                                    if (!label || typeof label !== 'string') return '';
                                    const [hour, minute] = label.split(':').map(Number);
                                    return (minute >= 58 || minute <= 2) ? `${hour}:00` : '';
                                }
                            },
                            offset: true,
                            display: true,
                            bounds: 'ticks'
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: {
                            common: { drawTime: 'beforeDatasetsDraw' },
                            annotations: {
                                rangoOptimo: {
                                    type: 'box',
                                    yMin: 70,
                                    yMax: 150,
                                    backgroundColor: 'rgba(0, 200, 0, 0.1)',
                                    borderColor: 'rgba(0, 200, 0, 0.2)',
                                    borderWidth: 1,
                                    drawTime: 'beforeDatasetsDraw'
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateGraphView() {
            if (!glucoseChart || !allGlucoseData) return;

            const visibleData = allGlucoseData.slice(viewStartIndex, viewStartIndex + POINTS_TO_SHOW);
            if (visibleData.length === 0) return;

            const times = [];
            const values = [];

            let lastEntry = null;
            for (let i = 0; i < visibleData.length; i++) {
                const entry = visibleData[i];
                if (!entry || !entry.time || !entry.value) continue;

                const value = parseInt(entry.value);
                if (isNaN(value)) continue;

                if (!lastEntry) {
                    times.push(entry.time);
                    values.push(value);
                    lastEntry = entry;
                    continue;
                }

                const [lastHour, lastMinute] = lastEntry.time.split(':').map(Number);
                const [currentHour, currentMinute] = entry.time.split(':').map(Number);

                let minuteDiff = (currentHour - lastHour) * 60 + (currentMinute - lastMinute);
                if (minuteDiff < 0) minuteDiff += 24 * 60;

                if (minuteDiff > 5) {
                    const steps = Math.floor(minuteDiff / 5);
                    for (let step = 1; step < steps; step++) {
                        const interpolatedMinutes = (lastMinute + step * 5) % 60;
                        const interpolatedHours = lastHour + Math.floor((lastMinute + step * 5) / 60);
                        const interpolatedTime = `${String(interpolatedHours).padStart(2,'0')}:${String(interpolatedMinutes).padStart(2,'0')}`;
                        times.push(interpolatedTime);
                        values.push(null);
                    }
                }

                times.push(entry.time);
                values.push(value);
                lastEntry = entry;
            }

            if (times.length === 0 || values.length === 0) return;

            const validValues = values.filter(v => v !== null);
            const avgText = validValues.length ? `Promedio: ${Math.round(validValues.reduce((a,b)=>a+b,0)/validValues.length)} mg/dL` : 'Promedio: -- mg/dL';
            document.getElementById('graphAvg').textContent = avgText;

            glucoseChart.data.labels = times;
            glucoseChart.data.datasets[0].data = values;

            const annotations = {
                rangoOptimo: {
                    type: 'box',
                    yMin: 70,
                    yMax: 150,
                    backgroundColor: 'rgba(0, 200, 0, 0.1)',
                    borderColor: 'rgba(0, 200, 0, 0.2)',
                    borderWidth: 1,
                    drawTime: 'beforeDatasetsDraw'
                }
            };

            if (patientMarkers && patientMarkers.length > 0) {
                const firstVisibleTime = times[0];
                const lastVisibleTime = times[times.length - 1];

                const getMinutes = (timeStr) => {
                    const [hours, minutes] = timeStr.split(':').map(Number);
                    return hours * 60 + minutes;
                };

                const firstMinutes = getMinutes(firstVisibleTime);
                const lastMinutes = getMinutes(lastVisibleTime);

                const validTimes = new Set(times);

                patientMarkers.forEach((marker, index) => {
                    const markerMinutes = getMinutes(marker.time);

                    let isInRange = false;
                    if (firstMinutes <= lastMinutes) {
                        isInRange = markerMinutes >= firstMinutes && markerMinutes <= lastMinutes;
                    } else {
                        isInRange = markerMinutes >= firstMinutes || markerMinutes <= lastMinutes;
                    }

                    if (isInRange) {
                        let xValue = marker.time;
                        if (!validTimes.has(marker.time)) {
                            let closestTime = marker.time;
                            let minDiff = Infinity;

                            times.forEach(time => {
                                const diff = Math.abs(getMinutes(time) - markerMinutes);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    closestTime = time;
                                }
                            });

                            xValue = closestTime;
                        }

                        annotations[`marker${index}`] = {
                            type: 'point',
                            xValue,
                            yValue: marker.value,
                            backgroundColor: marker.color,
                            radius: marker.radius || 4,
                            borderColor: marker.borderWidth === 0 ? marker.color : 'white',
                            borderWidth: marker.borderWidth !== undefined ? marker.borderWidth : 2,
                            drawTime: marker.type === 'AUTO_BASAL_DELIVERY' ? 'afterDatasetsDraw' : 'beforeDatasetsDraw',
                            pointStyle: marker.pointStyle || 'circle'
                        };
                    }
                });
            }

            glucoseChart.options.plugins.annotation.annotations = annotations;
            glucoseChart.update();
        }

        function updateCalibrationIndicator(timeToCalib, calibrationStatus, sensorStatus) {
            const circle = document.getElementById('calibrationCircle');
            const drop = document.getElementById('calibrationDrop');

            drop.className = 'calibration-drop';
            circle.className = 'calibration-circle';

            if (timeToCalib === 255 || calibrationStatus === "UNKNOWN") {
                circle.style.transform = 'translate(-50%, -50%)';
                circle.style.borderColor = '#00cccc';
                drop.classList.add('drop-unk');
            } else if (timeToCalib >= 12) {
                circle.style.transform = 'translate(-50%, -50%)';
                circle.style.borderColor = '#33cc00';
                drop.classList.add('drop-white');
            } else if (timeToCalib > 0) {
                const degrees = (timeToCalib / 12) * 360;

                circle.style.borderColor = timeToCalib > 3 ? '#33cc00' : '#ff0000';
                drop.classList.add('drop-white');

                circle.style.transform = 'translate(-50%, -50%) rotate(-90deg)';

                if (degrees <= 180) {
                    circle.classList.add('right');
                    circle.style.clip = 'rect(0, 14px, 28px, 0)';
                    const rightHalf = document.createElement('div');
                    rightHalf.className = 'calibration-circle right';
                    rightHalf.style.transform = `translate(-50%, -50%) rotate(-90deg) rotate(${degrees}deg)`;
                    rightHalf.style.borderColor = circle.style.borderColor;
                    rightHalf.style.clip = 'rect(0, 28px, 28px, 14px)';
                    circle.parentNode.insertBefore(rightHalf, circle.nextSibling);
                } else {
                    circle.classList.add('left');
                    circle.style.clip = 'rect(0, 28px, 28px, 14px)';
                    const leftHalf = document.createElement('div');
                    leftHalf.className = 'calibration-circle left';
                    leftHalf.style.transform = `translate(-50%, -50%) rotate(-90deg) rotate(${degrees - 180}deg)`;
                    leftHalf.style.borderColor = circle.style.borderColor;
                    leftHalf.style.clip = 'rect(0, 14px, 28px, 0)';
                    circle.parentNode.insertBefore(leftHalf, circle);
                }
            } else {
                if (sensorStatus === "CALIBRATION_REQUIRED") {
                    circle.style.transform = 'translate(-50%, -50%)';
                    circle.style.borderColor = 'transparent';
                    drop.classList.add('drop-red');
                } else {
                    circle.style.transform = 'translate(-50%, -50%)';
                    circle.style.borderColor = 'transparent';
                    drop.classList.add('drop-white');
                }
            }

            const oldCircles = document.querySelectorAll('.calibration-circle:not(#calibrationCircle)');
            oldCircles.forEach(oldCircle => oldCircle.remove());
        }

        function updatePumpData() {
            // Datos principales
            fetch('/api/pump-data')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('glucoseValue').textContent = data.glucose;

                    updateCalibrationIndicator(data.time_to_calib, data.calibration_status, data.sensor_status);

                    const glucoseTrend = data.trend || 'none';
                    document.getElementById('shieldImage').src = `/static/res/mm_shield_${glucoseTrend}.png`;

                    // Nivel del reservorio → ícono
                    let img_lvl = 0;
                    if (data.reservoir > 150) {
                        img_lvl = 200; // verde
                    } else if (data.reservoir > 80) {
                        img_lvl = 150; // amarillo
                    } else if (data.reservoir > 1) {
                        img_lvl = 50;  // rojo
                    } else {
                        img_lvl = 0;   // empty
                    }

                    // Íconos de status
                    document.getElementById('batteryIcon').src = `/static/res/mm_batt${data.battery}.png`;
                    document.getElementById('reservoirIcon').src = `/static/res/mm_tank${img_lvl}.png`;
                    document.getElementById('sensorConnIcon').src = `/static/res/mm_sensor_connection_${data.sensor_connection ? 'ok' : 'nok'}.png`;
                    document.getElementById('sensorAgeIcon').src = `/static/res/mm_sage_${data.sensor_age ? 'green' : 'unk'}.png`;

                    // Textos
                    document.getElementById('lastUpdate').textContent = data.last_update;
                    document.getElementById('sensorAgeText').textContent = data.sensor_age;
                    document.getElementById('activeInsulin').textContent = data.active_insulin;
                    document.getElementById('lastUpdateText').textContent = data.time_ago;

                    // --- Banner de estado (objetivo temporal, suspend, etc.) ---
                    const bannerEl = document.getElementById('pumpBanner');
                    const bannerMap = {
                        'temp_target': 'mm_banner_temp_target.png',
                        'delivery_suspend': 'mm_banner_delivery_suspend.png'
                        // agrega más si tienes: 'exercise_mode': 'mm_banner_exercise.png'
                    };
                    const rawBanner = (data.banner_state || '').toString();
                    const key = rawBanner.trim().toLowerCase().replace(/\s+/g, '_').replace(/-/g, '_');
                    if (key && bannerMap[key]) {
                        bannerEl.src = `/static/res/${bannerMap[key]}`;
                        bannerEl.style.display = 'block';
                    } else {
                        bannerEl.style.display = 'none';
                    }
                })
                .catch(error => console.error('Error:', error));

            // Datos del gráfico
            fetch('/api/pump-graph-data')
                .then(response => response.json())
                .then(data => {
                    allGlucoseData = data.glucose_history || [];
                    patientMarkers = data.markers || [];
                    viewStartIndex = Math.max(0, allGlucoseData.length - POINTS_TO_SHOW);
                    updateGraphView();
                })
                .catch(error => console.error('Error:', error));
        }

        // Inicializar
        document.addEventListener('DOMContentLoaded', function() {
            initializeChart();
            updatePumpData();
            setInterval(updatePumpData, 60000);
        });

        // Slider principal (touch)
        let currentSlide = 0;
        const slider = document.querySelector('.slider-wrapper');
        const dots = document.querySelectorAll('.dot');
        let startX = 0;

        slider.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            slider.style.transition = 'none';
        });

        slider.addEventListener('touchmove', (e) => {
            if (startX === 0) return;
            const touch = e.touches[0];
            const diff = touch.clientX - startX;
            const translateX = -currentSlide * 100 + (diff / window.innerWidth * 100);
            if (translateX <= 0 && translateX >= -100) {
                slider.style.transform = `translateX(${translateX}vw)`;
            }
        });

        slider.addEventListener('touchend', (e) => {
            const diff = e.changedTouches[0].clientX - startX;
            const threshold = window.innerWidth * 0.2;
            slider.style.transition = 'transform 0.3s ease-out';
            if (Math.abs(diff) > threshold) {
                if (diff > 0 && currentSlide > 0) currentSlide--;
                else if (diff < 0 && currentSlide < 1) currentSlide++;
            }
            slider.style.transform = `translateX(${-currentSlide * 100}vw)`;
            updateDots();
            startX = 0;
        });

        function updateDots() {
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index === currentSlide);
            });
        }

        // Gestos sobre el gráfico
        let graphStartX = 0;
        let graphLastX = 0;
        let graphVelocity = 0;
        let lastTime = 0;
        let isGraphDragging = false;
        const graph = document.getElementById('graph');

        graph.addEventListener('touchstart', (e) => {
            graphStartX = e.touches[0].clientX;
            graphLastX = graphStartX;
            lastTime = Date.now();
            graphVelocity = 0;
            isGraphDragging = true;
            e.stopPropagation();
        });

        graph.addEventListener('touchmove', (e) => {
            if (!isGraphDragging) return;
            const currentX = e.touches[0].clientX;
            const currentTime = Date.now();
            const timeDiff = currentTime - lastTime;
            if (timeDiff > 0) graphVelocity = (currentX - graphLastX) / timeDiff;

            const diff = currentX - graphLastX;
            const pointsToMove = diff * 0.1;
            viewStartIndex = Math.max(0, Math.min(
                allGlucoseData.length - POINTS_TO_SHOW,
                viewStartIndex - pointsToMove
            ));
            updateGraphView();

            graphLastX = currentX;
            lastTime = currentTime;
            e.stopPropagation();
        });

        graph.addEventListener('touchend', (e) => {
            if (!isGraphDragging) return;
            const endX = e.changedTouches[0].clientX;
            const totalDiff = endX - graphStartX;
            const swipeVelocity = Math.abs(graphVelocity);
            if (swipeVelocity > 1.5 && totalDiff > window.innerWidth * 0.4) {
                currentSlide = 0;
                slider.style.transition = 'transform 0.3s ease-out';
                slider.style.transform = 'translateX(0)';
                updateDots();
            }
            isGraphDragging = false;
            graphStartX = 0;
            graphVelocity = 0;
            e.stopPropagation();
        });
    </script>
</body>
</html>
